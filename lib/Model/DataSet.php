<?php


/**
 * DataSet
 *
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   http://github.com/swagger-api/swagger-codegen
 * @license  http://www.apache.org/licenses/LICENSE-2.0 Apache Licene v2
 * @link     https://github.com/swagger-api/swagger-codegen
 */
/**
 *  Copyright 2016 SmartBear Software
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Model;

use \ArrayAccess;
/**
 * DataSet Class Doc Comment
 *
 * @category    Class
 * @description DataSet object
 * @package     Swagger\Client
 * @author      http://github.com/swagger-api/swagger-codegen
 * @license     http://www.apache.org/licenses/LICENSE-2.0 Apache Licene v2
 * @link        https://github.com/swagger-api/swagger-codegen
 */
class DataSet implements ArrayAccess
{
    /**
      * The original name of the model.
      * @var string
      */
    static $swaggerModelName = 'DataSet';

    /**
      * Array of property to type mappings. Used for (de)serialization 
      * @var string[]
      */
    static $swaggerTypes = array(
        'name' => 'string',
        'n_gram_count' => 'int',
        'id_field' => 'string',
        'tag_field' => 'string',
        'interpreted_fields' => 'string[]',
        'statistics' => '\Swagger\Client\Model\DataSetStats',
        'sample_document' => 'object',
        'schema' => 'object'
    );
  
    static function swaggerTypes() {
        return self::$swaggerTypes;
    }

    /** 
      * Array of attributes where the key is the local name, and the value is the original name
      * @var string[] 
      */
    static $attributeMap = array(
        'name' => 'Name',
        'n_gram_count' => 'NGramCount',
        'id_field' => 'IdField',
        'tag_field' => 'TagField',
        'interpreted_fields' => 'InterpretedFields',
        'statistics' => 'Statistics',
        'sample_document' => 'SampleDocument',
        'schema' => 'Schema'
    );
  
    static function attributeMap() {
        return self::$attributeMap;
    }

    /**
      * Array of attributes to setter functions (for deserialization of responses)
      * @var string[]
      */
    static $setters = array(
        'name' => 'setName',
        'n_gram_count' => 'setNGramCount',
        'id_field' => 'setIdField',
        'tag_field' => 'setTagField',
        'interpreted_fields' => 'setInterpretedFields',
        'statistics' => 'setStatistics',
        'sample_document' => 'setSampleDocument',
        'schema' => 'setSchema'
    );
  
    static function setters() {
        return self::$setters;
    }

    /**
      * Array of attributes to getter functions (for serialization of requests)
      * @var string[]
      */
    static $getters = array(
        'name' => 'getName',
        'n_gram_count' => 'getNGramCount',
        'id_field' => 'getIdField',
        'tag_field' => 'getTagField',
        'interpreted_fields' => 'getInterpretedFields',
        'statistics' => 'getStatistics',
        'sample_document' => 'getSampleDocument',
        'schema' => 'getSchema'
    );
  
    static function getters() {
        return self::$getters;
    }

    
    /**
      * $name Name of your dataset. Can contains just A-Z letters, numbers, _ (underscore) and - (hyphen) without any space. This field is unique
      * @var string
      */
    protected $name;
    
    /**
      * $n_gram_count To deeper analyze your text, a dataset uses ngram to index your document. You can set the ngramcount from 1 to 6
      * @var int
      */
    protected $n_gram_count;
    
    /**
      * $id_field To identify a document you need to use IDs. You can use your own conventions to name your ID field, but in the settings you need to provide the field name of the id field from your sample document. Can contains just A-Z letters, numbers, _ (underscore) and - (hyphen) without any space
      * @var string
      */
    protected $id_field;
    
    /**
      * $tag_field For text categorization, we provide a predefined document field to store your tags (or categories). If your documents are related to tags or categories, please insert here the tags field name from your sample JSON. Can contains just A-Z letters, numbers, _ (underscore) and - (hyphen) without any space
      * @var string
      */
    protected $tag_field;
    
    /**
      * $interpreted_fields For text analysis, you can set those document fields that contains useful text content. Slamby is doing ngram analysis and text process related works on these fields. How to decide which field you need to set here? Only the interpreted field can be a part of text analyzes. To provide these fields just simply insert the needed text fields from your JSON document. Field names can contain just A-Z letters, numbers, _ (underscore) and - (hyphen) without any space
      * @var string[]
      */
    protected $interpreted_fields;
    
    /**
      * $statistics These are read-only calculated values
      * @var \Swagger\Client\Model\DataSetStats
      */
    protected $statistics;
    
    /**
      * $sample_document Using flexible document schema, you can store all of your required data inside one simple dataset. To create a dataset with your required schema you can provide a sample document. The schema is flexible; the only requirement is using standard JSON format. Field names can contain just A-Z letters, numbers, _ (underscore) and - (hyphen) without any space
      * @var object
      */
    protected $sample_document;
    
    /**
      * $schema Using flexible document schema, you can store all of your required data inside one simple dataset. To create a dataset with your required schema you can provide a schema. The schema is flexible. Field names can contain just A-Z letters, numbers, _ (underscore) and - (hyphen) without any space
      * @var object
      */
    protected $schema;
    

    /**
     * Constructor
     * @param mixed[] $data Associated array of property value initalizing the model
     */
    public function __construct(array $data = null)
    {
        
        

        if ($data != null) {
            $this->name = $data["name"];
            $this->n_gram_count = $data["n_gram_count"];
            $this->id_field = $data["id_field"];
            $this->tag_field = $data["tag_field"];
            $this->interpreted_fields = $data["interpreted_fields"];
            $this->statistics = $data["statistics"];
            $this->sample_document = $data["sample_document"];
            $this->schema = $data["schema"];
        }
    }
    
    /**
     * Gets name
     * @return string
     */
    public function getName()
    {
        return $this->name;
    }
  
    /**
     * Sets name
     * @param string $name Name of your dataset. Can contains just A-Z letters, numbers, _ (underscore) and - (hyphen) without any space. This field is unique
     * @return $this
     */
    public function setName($name)
    {
        
        $this->name = $name;
        return $this;
    }
    
    /**
     * Gets n_gram_count
     * @return int
     */
    public function getNGramCount()
    {
        return $this->n_gram_count;
    }
  
    /**
     * Sets n_gram_count
     * @param int $n_gram_count To deeper analyze your text, a dataset uses ngram to index your document. You can set the ngramcount from 1 to 6
     * @return $this
     */
    public function setNGramCount($n_gram_count)
    {
        
        $this->n_gram_count = $n_gram_count;
        return $this;
    }
    
    /**
     * Gets id_field
     * @return string
     */
    public function getIdField()
    {
        return $this->id_field;
    }
  
    /**
     * Sets id_field
     * @param string $id_field To identify a document you need to use IDs. You can use your own conventions to name your ID field, but in the settings you need to provide the field name of the id field from your sample document. Can contains just A-Z letters, numbers, _ (underscore) and - (hyphen) without any space
     * @return $this
     */
    public function setIdField($id_field)
    {
        
        $this->id_field = $id_field;
        return $this;
    }
    
    /**
     * Gets tag_field
     * @return string
     */
    public function getTagField()
    {
        return $this->tag_field;
    }
  
    /**
     * Sets tag_field
     * @param string $tag_field For text categorization, we provide a predefined document field to store your tags (or categories). If your documents are related to tags or categories, please insert here the tags field name from your sample JSON. Can contains just A-Z letters, numbers, _ (underscore) and - (hyphen) without any space
     * @return $this
     */
    public function setTagField($tag_field)
    {
        
        $this->tag_field = $tag_field;
        return $this;
    }
    
    /**
     * Gets interpreted_fields
     * @return string[]
     */
    public function getInterpretedFields()
    {
        return $this->interpreted_fields;
    }
  
    /**
     * Sets interpreted_fields
     * @param string[] $interpreted_fields For text analysis, you can set those document fields that contains useful text content. Slamby is doing ngram analysis and text process related works on these fields. How to decide which field you need to set here? Only the interpreted field can be a part of text analyzes. To provide these fields just simply insert the needed text fields from your JSON document. Field names can contain just A-Z letters, numbers, _ (underscore) and - (hyphen) without any space
     * @return $this
     */
    public function setInterpretedFields($interpreted_fields)
    {
        
        $this->interpreted_fields = $interpreted_fields;
        return $this;
    }
    
    /**
     * Gets statistics
     * @return \Swagger\Client\Model\DataSetStats
     */
    public function getStatistics()
    {
        return $this->statistics;
    }
  
    /**
     * Sets statistics
     * @param \Swagger\Client\Model\DataSetStats $statistics These are read-only calculated values
     * @return $this
     */
    public function setStatistics($statistics)
    {
        
        $this->statistics = $statistics;
        return $this;
    }
    
    /**
     * Gets sample_document
     * @return object
     */
    public function getSampleDocument()
    {
        return $this->sample_document;
    }
  
    /**
     * Sets sample_document
     * @param object $sample_document Using flexible document schema, you can store all of your required data inside one simple dataset. To create a dataset with your required schema you can provide a sample document. The schema is flexible; the only requirement is using standard JSON format. Field names can contain just A-Z letters, numbers, _ (underscore) and - (hyphen) without any space
     * @return $this
     */
    public function setSampleDocument($sample_document)
    {
        
        $this->sample_document = $sample_document;
        return $this;
    }
    
    /**
     * Gets schema
     * @return object
     */
    public function getSchema()
    {
        return $this->schema;
    }
  
    /**
     * Sets schema
     * @param object $schema Using flexible document schema, you can store all of your required data inside one simple dataset. To create a dataset with your required schema you can provide a schema. The schema is flexible. Field names can contain just A-Z letters, numbers, _ (underscore) and - (hyphen) without any space
     * @return $this
     */
    public function setSchema($schema)
    {
        
        $this->schema = $schema;
        return $this;
    }
    
    /**
     * Returns true if offset exists. False otherwise.
     * @param  integer $offset Offset 
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->$offset);
    }
  
    /**
     * Gets offset.
     * @param  integer $offset Offset 
     * @return mixed 
     */
    public function offsetGet($offset)
    {
        return $this->$offset;
    }
  
    /**
     * Sets value based on offset.
     * @param  integer $offset Offset 
     * @param  mixed   $value  Value to be set
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        $this->$offset = $value;
    }
  
    /**
     * Unsets offset.
     * @param  integer $offset Offset 
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->$offset);
    }
  
    /**
     * Gets the string presentation of the object
     * @return string
     */
    public function __toString()
    {
        if (defined('JSON_PRETTY_PRINT')) { // use JSON pretty print
            return json_encode(\Swagger\Client\ObjectSerializer::sanitizeForSerialization($this), JSON_PRETTY_PRINT);
        }

        return json_encode(\Swagger\Client\ObjectSerializer::sanitizeForSerialization($this));
    }
}


